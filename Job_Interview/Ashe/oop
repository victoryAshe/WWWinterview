### 객체지향 프로그래밍

#### 객체지향 프로그래밍 이전 패러다임

  1. 순차적, 비구조적 프로그래밍 : 말그대로 순차적으로 코딩해 나가는 것, 필요한 것이 있으면 순서를 추가해가면서 구현하는 방식이다. 직관적이지만 goto문을 활용하므로서 규모가 매우 커지게 되고 나중엔 코드가 어떻게 연결되었는지 구분하기 매우 어렵다.
  2. 절차적, 구조적 프로그래밍 : 위 프로그래밍 방식을 개선하기 위해 나온 패러다임이다. 반복될 가능성이 높은 함수(프로시저)들을 따로 만들어 사용하는 방식이다. 하나의 큰기능을 처리하기 위해 작은 단위의 기능들으로 나누어 처리하고 비교적 작은 규모의 작업을 수행하는 함수를 생성한다. 하지만 이러한 절차적, 구조적 프로그래밍은 함수(논리적 단위)는 표현이 되지만 실제 데이터에 대한 변수 나 상수(물리적 단위)의 표현에는 어려움이 있다. 이러한 단점은 프로그램을 비효율적으로 코딩하게 되고 결국은 유지보수와 디버깅에 어려움을 가져온다. 즉  큰 규모의 작업으로 갈 수 록 더 효율적인 모듈화와 데이터 관리가 필요하다 그렇기에 나온게 데이터와 함수를 동시에 관리 할 수 있는 객체지향 프로그래밍이 각광받게 된다.

#### 객체 지향 프로그래밍이란?

   객체 지향 프로그래밍은 특정한 개념의 함수와 자료형을 함께 묶어서 관리하기 위해 탄생한 것이다. 즉 객체 내부에 자료형(필드)와 함수(메소드) 가 같이 존재 한다. 객체지향 프로그래밍을 하면 객체간의 독립성이 생기고 중복코드의 양이 줄어드는 장점이 있다. 또한 독립성이 확립되면서 유지보수에도 큰 도움을 주게 된다.

   또한 이러한 객체들 끼리 서로 상호작용하면서 어떠한 문제를 해결해 나가는 것이 객체지향 프로그램이다.

#### 객체 지향 프로그래밍의 특성

  1. 추상화(Abstraction)

     어떤 영역에서 필요로 하는 속성이나 행동을 추출하는 작업 , 즉 모델화

     - 사물들의 공통된 특징, 즉 추상적 특징을 파악해 인식의 대상으로 삼는 행위
     - 구체적인 사물들의 공통적인 특징을 파악해서 이를 하나의 개념(집합)으로 다루는 수단

     >구체적인 개념에 의존
     >
     >```java
     >switch(동물의 종류){
     >  case 사자 : //somthing
     >  case 호랑이 : // something
     >  case 토끼 : // someting
     >}
     >```
     >
     >새로운 종이 추가 되면 코드를 새로 추가 해야함
     >
     >
     >
     >추상적인 개념에 의존
     >
     >```java
     >void something(Animal a){
     >  a.something();
     >}
     >```
     >
     >새로운 종이 나와도 코드를 변경 할 필요가 없다. 뒤에서 다형성에 의한 오버라이드로 처리

  2. 캡슐화(Encapsulation)

      높은 응집도(Cohesion) 과 낮은 결합도(Coupling) 를 유지해야 요구사항에 맞춰 유연하게 대처 할 수 있다.

     - 응집도 : 모듈(클래서) 내에서 요소들이 얼마나 밀접하게 관련이 있는지, 응집도는 정보 은닉을 통해 높일 수 있다. 즉, 내부에서만 사용하는 정보는 외부에서 접근하지 못하도록 제한하는 것이다. Ex) private
     - 결합도 : 어떠한 기능을 수행하는데 다른 모듈(클래스)에 얼마나 의존적인지

  3. 일반화(Generalization) : 상속

     이미 정의된 상위클래스의 모든 속성과 연산을 하위클래스가 물려 받는 것을 의미한다.

     - 일반화를 이용 하면 상위 클래스로 부터 상속받은 하위 클래스는 모든 속성(필드)과 연산(메소드)을 다시 정의하지 않고 자신의 것으로 사용 할 수있다.
     - 상속받은 속성과 연산 외에 새로운 속성과 연산을 추가하여 사용 가능하다.
     - 클래스를 재사용 하므로서 소프트웨어 재사용성을 증대시키는 중요한 개념이다.

  4. 다형성(Polymorphism)

     1. Pure Polymorphism : 서로 다른 클래스의 객체가 같은 메세지를 받았을때 각자의 방식으로 동작하는 능력이다.
        - 일반화와 함께 프로그램을 변화에 유연하게 만든다.
        - 다형성을 사용할 경우 어떤 클래스가 참조 되었는지 무관하게 프로그래밍 할 수 있다.

     2. Ad hoc polymorphism : Overridng & Overloading

     3. Generics (parameter type) : T (type parameter, 어떤 타입이 와도 무관)

#### 객체지향 설계 원칙 SOLID

1. SRP(단일 책임의 원칙 : Single Responsibility Principle) : 작성된 클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는데 집중되어 있어야 한다는 원칙

2. OCP(개방폐쇄의 원칙 : Open Close Principle) : 소프트웨어의 구성요소는 확장에는 열려있고, 변경에는 닫혀있어야 한다는 원칙. 변경은 최소화 하고 확장을 최대화

3. LSP(리스코브 치환의 원칙 : The Liskov Substitution Principle) : 서브타입은 언제나 기반 타입으로 교체할 수 있어야 한다는 원칙, 즉 항상 하위 클래스는 상위 클래스를 대신할 수 있다. 상위클래스가 할 수 있는 일들에 대해선 하위클래스는 당연히 할 수 있다는 원칙이다.

4. ISP(인터페이스 분리의 원칙 : Interface Segregation Principle) : 인터페이스 분리 원칙은 클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙이다. 인터페이스 분리 원칙은 큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리시킴으로써 클라이언트들이 꼭 필요한 메서드들만 이용할 수 있게 한다. SRP 는 클래스의 단일 책임이라면 ISP는 인터페이스의 단일 책임을 강조하는 것이다.

5. DIP(의존성 역전의 원칙 : Dependency Inversion Principle) : 자주 변화하는 구체적인 클래스 보다는 변화하기 어려운 인터페이스나 상위(추상) 클래스와 관계를 맺으라는 원칙
